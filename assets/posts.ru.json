[{
        "title": "Слияние моих локальных изменений с другой веткой",
        "content": "Это можно сделать прямо в процессе стандартного слияния (`merge`). Вам стоит *сохранить историю слияний* используя флаг `--no-ff`, что означает _no fast forward_. \n\n Перейдите в ветку, в которую будут вливаться изменения, убедитесь в её актуальности и запустите процесс: \n\n `git merge <другая-ветка> --no-ff` \n\n Затем появится сообщение о коммите `merge X into Y branch`, после чего вы можете смело запушить ваше слияние.>",
        "help": "modify undo commit after push reset изменение отменённого коммита"
},
{
        "title": "Отмена коммита до публикации изменений",
        "content": "Если вы сделали коммит, который впоследствии понадобилось отредактировать или полностью стереть, поможет команда git `reset`. \n\n `git reset HEAD~1 # отменить последний коммит, сохранить изменения` \n\n `git reset --hard HEAD~1 #отменить последний коммит, стереть изменения` \n\n Будьте осторожны используя второй вариант, поскольку изменения ваших локальных файлов будут потеряны. \n\n Чтобы сохранить сообщение коммита, наберите: :\n\n `git commit -i ORIG_HEAD`\n\n Подсказал [hrbonz](https://github.com/hrbonz)",
        "help": "modify undo commit local before push reset изменение отмена коммита до публикации"
},
{
        "title": "Восстановление удалённой ветки",
        "content": "С помощью команды `git reflog` можно узнать хэш (SHA1) последнего коммита в удалённой ветке. Скопируйте этот хэш и используйте в команде: \n\n `git checkout <sha>` \n\n После этого восстановить удалённую ветку можно будет вот такой командой: \n\n `git checkout -b <название-ветки>`",
        "help": "recover deleted branch восстановление удалённой ветки",
        "cmds": "git reflog"
},
{
        "title": "Отобразить коммиты, содержащие удалённые файлы",
        "content": "Узнать, в каких коммитах содержатся удалённые файлы, можно с помощью команды: \n\n `git log --diff-filter=D --summary` \n\n Она покажет список коммитов, в которых удалялись файлы.",
        "help": "display show deleted files history отображение истории удаления файлов"
},
{
        "title": "Синхронизировать ветку с master-репозиторием",
        "content": "Чтобы синхронизировать последние изменения в репозитории master (или с любой другой веткой, с которой вы работали) необходимо «перебазировать» локальную ветку. Предположим, вы работаете над веткой `foobar`:\n\n `git checkout foobar` \n\n А затем осуществляете «перебазирование»: \n\n `git rebase master` \n\n После этого будут применены коммиты `origin` из master. После разрешения конфликтов процесс можно продолжить с помощью команды `git rebase --continue`. Теперь можно продолжать работу над своей веткой или осуществить её слияние (merge) с главным репозиторием. \n\n Подробнее о [перебазировании](https://github.com/k88hudson/git-flight-rules#i-need-to-combine-commits)",
        "help": "rebase branch against master changes перенос изменений из master в локальную ветку"
},
{
        "title": "Восстановление удалённого файла",
        "content": "Если вы случайно удалили файл, его можно быстро восстановить: \n\n `git checkout myfile.txt` \n\n Если требуется восстановить файл из конкретной временной точки истории коммитов, следует узнать хеш нужного коммита и запустить команду: \n\n `git checkout $commit~1 myfile.txt`",
        "help": "restore recover deleted file восстановление удалённого файла"
},
{
        "title": "Отмена локальных изменений файлов",
        "content": "Простейшим способом избавиться от нежелательных изменений для файлов и папок является восстановление состояния последнего коммита. Сделать это можно с помощью специальной команды: \n\n `git checkout myfile.txt` \n\n Кроме того, можно восстановить конкретный путь к файлу: \n\n `git checkout -- путь-до-файла`",
        "help": "revert reset file specific version восстановление конкретной версии файла"
},
{
        "title": "Очистка всех скрытых состояний",
        "content": "Очистить все скрытые состояния можно следующей командой: \n\n `git stash clear`",
        "help": "clear stash очистка скрытых состояний"
},
{
        "title": "Удаление неотслеживаемых файлов и папок",
        "content": " Чтобы удалить неотслеживаемые файлы и папки из рабочей копии наберите следующую команду: \n\n `git clean -f` \n\n Чтобы в принципе удалить их: \n\n `git clean -fd` \n\n Подсказка: чтобы увидеть, какие файлы являются лишними, перед их непосредственным удалением, наберите: \n\n `git clean -n`",
        "help": "очистка мусорных файлов remove clear untracked files",
        "cmds": "git clean"
},
{
        "title": "Изменение сообщения коммита перед его отправкой",
        "content": "Изменить сообщение коммита можно с помощью команды `git commit --amend`, она откроет редактор, в котором можно будет внести необходимые поправки в последнее сообщение. \n\n Сообщение можно изменить и напрямую с помощью команды \n\n `git commit --amend -m \"Новое прекрасное сообщение\"`",
        "help": "undo commit message before pushing amend изменение сообщения коммита перед отправкой"
},
{
        "title": "Отсортировать коммиты по автору",
        "content": "Чтобы вывести список коммитов, отфильтрованных по автору, следует воспользоваться следующей командой: \n\n `git log --author=\"Имя автора\"`",
        "help": "display show commits by author name отображение коммитов, отфильтрованных по автору",
        "cmds": "git log author"
},
{
        "title": "Поиск конкретного сообщения во всех коммитах",
        "content": " Чтобы найти конкретный текст сообщения коммита, соответствующий регулярному выражению, нужно воспользоваться командой\n\n `git log --grep <запрос>`",
        "help": "search commit message regexp log find поиск сообщения коммита с помощью регулярного выражения"
},
{
        "title": "Изменение сообщения коммита после его отправки",
        "content": "В данном случае процесс занимает два шага. Сначала нужно изменить сообщение с помощью команды `git commit --amend`, а затем перезаписать историю коммитов локальной ветки: `git push <remote> <branch> --force` \n\n **Предупреждение:** подобная насильная перезапись может привести к потери коммитов из внешней ветки, если с ней давно не было синхронизации, соблюдайте осторожность.",
        "help": "undo commit message after pushing amend изменение сообщения коммита после его отправки"
},
{
        "title": "Совмещение двух и более коммитов",
        "content": "Здесь нам понадобится произвести интерактивное перебазирование. Если перебазирование происходит относительно master-ветки, то начать следует с команды `git rebase -i master`. Однако, если перебазирование происходит не относительно ветки, то нужно будет перебазироваться относительно `HEAD`.\n\n Если есть необходимость в совмещении двух последних коммитов, можно использовать команду \n\n `git rebase -i HEAD~2`.\n\n После её ввода появятся инструкции по выбору коммитов. В том случае, если необходимо совместить все коммиты с первым *старейшим* коммитов, то в первой строке нужно написать `pick`, а для всех остальных коммитов изменить букву на `f`. Подробнее [здесь](https://github.com/k88hudson/git-flight-rules#i-need-to-combine-commits) ",
        "help": "combine commits join rebase совмещение коммитов",
        "cmds": "git rebase"
},
{
        "title": "Удаление файла из git с сохранением его локальной копии",
        "content": "Для того, чтобы удалить файл из git, но сохранить его локально нужно использовать следующую команду:\n\n `git rm --cached myfile.txt`",
        "help": "remove file from git delete удаление файла из git"
},
{
        "title": "Просмотр старой ревизии файла",
        "content": "Существует возможность просмотреть содержимое файла в конкретный момент времени в прошлом. Для этого нужно использовать команду: \n\n `git show commitHash:myfile.txt`",
        "help": "compare old revision file просмотр старой ревизии файла",
        "cmds": "git show"
},
{
        "title": "Совмещение коммитов по конкретной функции для добавления в ветку релиза",
        "content": "Если вы решите совместить и опубликовать коммиты, то возникнет новый коммит в ветке релиза, поэтому история ветки конкретной функции останется неизменной.\n\n Ниже представлен пример того, как достичь подобного эффекта: \n\n `git fetch origin` \n\n `git checkout [release-branch]` \n\n `git rebase origin/[release-branch]` \n\n `git merge —squash —no-commit [feature-branch]` \n\n `git commit -m 'Merge X into Y'` \n\n В конечном итоге останется только один коммит в ветке релиза, а история изменений в ветке разработки конкретной функции останется нетронутой.\n\n [Подробнее о ветках функций](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow)",
        "help": "squash combine commits feature merge update release совмещение коммитов конкретной функции",
        "cmds": "git squash"
},
{
        "title": "Откат к конкретному коммиту в истории",
        "content": "Если вас не очень беспокоят изменения в локальном репозитории, то можно «откатиться» к конкретному коммиту в истории с помощью команды: \n\n `git reset --hard HEAD~1` \n\n Эта команда установит HEAD на конкретный коммит. Также можно воспользоваться хешем коммита.",
        "help": "revert reset commit certain history откат к конкретному коммиту в истории"
},
{
        "title": "Перестать отслеживать существующие файлы",
        "content": "Если вы хотите перестать отслеживать файлы, которые уже есть в репозитории, но при этом желаете сохранить его локально, осуществите коммит изменений и запустите команду: \n\n `git rm -r --cached` \n\n Она удалит изменённые файлы из зоны подготовленных файлов (staging area). Затем нужно запустить команду: \n\n `git add .` и отправить изменения.",
        "help": "untrack remove files already exist there снятие отметки с существующего файла"
},
{
        "title": "Восстановление удалённого тега",
        "content": "В том случае, если необходимо восстановить случайно удалённый тег, начать можно с его поиска: \n\n `git fsck --unreachable | grep tag` \n\n После того, как нужный тег найден, его следует восстановить: \n\n `git update-ref refs/tags/название-тега` \n\n [Источник](http://java.dzone.com/articles/git-tip-restore-deleted-tag)",
        "help": "recover undo deleted tag accident восстановление случайно удалённого тега"
},
{
        "title": "Создание новой ветки с изменениями текущей",
        "content": "Часто возникает ситуация, при которой пользователи начинают изменять файлы в ветке, чтобы что-то исправить, и лишь позднее вспоминают, что предварительно не создали новую ветку. К счастью, есть способ сделать это уже в процессе: \n\n `git checkout -b название-моей-новой-ветки` \n\n Эта команда перенесёт файлы из текущей ветки в новую, которую потом уже можно «закоммитить».",
        "help": "create new branch keep changes создание новой ветки с сохранением изменений"
},
{
        "title": "Публикация локальной ветки для удалённого редактирования",
        "content": "Если вы создали локальную ветку, и хотите, чтобы другие пользователи могли с ней работать, воспользуйтесь командой: \n\n `git push -u origin название-моей-новой-ветки` \n\n Теперь они тоже смогут вносить изменения в эту ветку.",
        "help": "push local branch remote публикация локальной ветки для удалённой работы"
},
{
        "title": "Восстановление накопленных изменений",
        "content": "В том случае, если изменения, внесённые пользователем, находятся в режиме накопления, применить их к ветке можно с помощью команды `git stash apply`. Также можно запустить `git diff` — эта команда поможет выявить различия. Для того, чтобы затем избавиться от накопленных данных, нужно запустить команду: \n\n `git stash drop` \n\n Если существует более одного накопления, найти нужное можно с помощью команды: \n\n `git stash list` затем можно применить его, воспользовавшись его индексом: \n\n `git stash@{1}` \n\n Необходимо учитывать, что отсчёт индексов ведётся от нуля. \n\n [Подробнее о накоплении](http://stackoverflow.com/questions/19003009/git-how-to-recover-stashed-uncommited-changes)",
        "help": "recover stash stash@ changes stashed восстановление накопленных изменений",
        "cmds": "git checkout stash"
},
{
        "title": "Переименование локальной и удалённой ветки",
        "content": "Предложим, у вас есть ветка _“fix-bug25”_, которую вы захотели переименовать в _“hotfix-users”_. Прежде всего, нужно будет изменить локальную ветку: \n\n `git branch -m fix-bug25 hotfix-users` \n\n А затем — удалённую ветку: переименовать её напрямую нельзя, поэтому нужно будет её удалить, и затем опубликовать заново уже с новым именем. Прежде чем приступать к этим процедурам, следует убедиться, что никто из членов команды не работает с этой веткой! Удаляем ветку: `git push origin :fix-bug25` \n\n А теперь заново публикуем её с новым именем: `git push origin hotfix-users`",
        "help": "rename wrong name branch переименование ветки"
},
{
        "title": "Отмена коммита после отправки его в master-репозиторий",
        "content": "Рассмотрим процедуру возврата одного или нескольких коммитов, которые нужно стереть из удалённой ветки. Обозначить конкретный коммит можно с помощью его хеша: \n\n `git revert b712c3c` \n\n Отмена только коммита, который является вторым после последнего: \n\n `git revert HEAD^` \n\n Простая отмена последнего коммита: \n\n `git revert -n HEAD` \n\n. [Подробнее о возврате](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)",
        "help": "undo revert commit pushed after push возврат коммитов",
        "cmds": "git revert"
},
{
        "title": "Убрать файл из буфера",
        "content": "Чтобы убрать добавленный по ошибке файл из буфера, нужно воспользоваться простой командой: \n\n `git reset HEAD unlovedfile.txt`",
        "help": "unstage file from remove commit убрать файл удалить коммит"
},
{
        "title": "Коммит в неправильную ветку",
        "content": "Нужно переключиться на новую ветку, которую вы забыли предварительно создать: \n\n `git checkout -b название-новой-ветки`. \n\n А затем переключиться к оригинальной ветке: \n\n `git checkout название-оригинальной-ветки` \n\n ...и «откатиться» до последнего коммита, который нужно сохранить. \n\n Чтобы это сделать, можно воспользоваться командой `git log` и сохранить хеш (SHA1) последнего коммита, который нужно оставить.. Например, это `a31a45c`. \n\n Теперь его нужно сбросить: `git reset --hard a31a45c` и отправить получившийся результат. \n\n **Предупреждение:** Убедитесь в том, что никто не отправлял коммиты в оригинальную ветку во время выполнения вышеописанных процедур, в противном случае эти изменения будут потеряны!",
        "help": "commit wrong branch master accident коммит в неправильную ветку"
},
{
        "title": "Удаление внешней ветки",
        "content": "Если вы хотите удалить ветку, введите команду: \n\n `git push origin --delete название-ветки`",
        "help": "delete remote branch удаление внешней ветки"
},
{
        "title": "Сброс локальной ветки до состояния удалённой",
        "content": "В том случае, если отсутствуют изменения, которые необходимо сохранить, сбросить локальную ветку до состояния удалённой можно с помощью двух простых команд.\n\n Прежде всего нужно получить свежие обновления из удалённой ветки: \n\n `git fetch название-удалённой-ветки`. \n\n А затем нужно сообщить git, что локальную ветку следует «откатить» до состояния удалённой: \n\n `git reset --hard origin/название-локальной-ветки`. \n\n При наличии коммита, который нужно сохранить, перед сбросом нужно создать новую ветку и произвести коммит: `git commit -m \"Обновление\"` \n\n `git branch название-новой-ветки`",
        "help": "reset local branch to match remote сброс локальной ветки до состояния удалённой"
},
{
        "title": "Отображения числа коммитов от каждого участника",
        "content": "Хотите узнать, сколько коммитов сделал каждый участник команды?\n\n Эта команда выведет список, отсортированный в порядке убывания количества коммитов: `git shortlog -s -n` \n\n.",
        "help": "show number commits показать число коммитов"
},
{
        "title": "Отображение всех коммитов одного файла",
        "content": "Если вы ходите просмотреть все коммиты с изменениями конкретного файла, воспользуйтесь командой `git log --follow -p -- myfile` \n\n Аргумент `--follow` позволяет вывести все изменения над файлом, даже если в процессе работы он был переименован. \n\n Если опустить опцию `-p`, то система выведет только сообщения коммитов, но не их содержимое.",
        "help": "show all commits file показать все коммиты файла",
        "cmds": "git log follow"
},
{
        "title": "Использование алиасов команд в командной строке",
        "content": "Устали каждый раз печатать `git status`? Этой команде можно присвоить простой алиас, который проще и быстрее вбивать в git. \n\n `git config --global alias.st status` \n\n — теперь нужно писать только `git st` \n\n Можно пойти дальше и присвоить алиасы более сложным командам: \n\n `git config --global alias.logme 'log -p --author=Rob'` \n\n Теперь алиас `git logme` будет выводить все наши коммиты.",
        "help": "command alias алиасы команд"
},
{
        "title": "Пометить конфликтующий файл, как разрешённый",
        "content": "Чтобы пометить один или несколько конфликтующих файлов, как разрешённые, чтобы их можно было нормально изменять, воспользуйтесь командой: \n\n `git add название-файла` \n\n Затем можно запустить `git commit`, чтобы разрешить конфликты и опубликовать изменения. \n\n Предложено Робертом Вюншем (Robert Wünsch).",
        "help": "conflict mark resolve file пометить конфликтный файл, как разрешённый",
        "cmds": "git add"
},
{
        "title": "Просмотр всех неотправленных коммитов",
        "content": "Чтобы просмотреть все коммиты, которые ещё не были отправлены в соответствующие ветки, воспользуйтесь следующей командой: \n\n `git log --branches --not --remotes` \n\n Кроме того, можно использовать: \n\n `git log origin/master..HEAD`",
        "help": "display show unpushed commits отображение неотправленных коммитов",
        "cmds": "git log"
},
{
        "title": "Переименование тега",
        "content": "Чтобы переименовать существующий тег: \n\n `git tag новое-название-тега старое-название-тега` \n\n `git tag -d старое-название-тега` \n\n `git push origin :refs/tags/старое-название-тега` \n\n `git push --tags`",
        "help": "rename tag name change переименование тега",
        "cmds": "git tag"
},
{
        "title": "Удаление старых веток, стёртых из внешнего репозитория",
        "content": "Если ветка удалена из внешнего репозитория, её также можно стереть из локального репозитория с помощью команды `git-remote prune название-удалённой-ветки`. \n\n Она удалит старую ветку под названием _название-удалённой-ветки_, которая уже была стёрта из внешнего репозитория, но всё ещё доступна локально в `remotes/название-удалённой-ветки`.",
        "help": "remove old prune branch удаление старой ветки",
        "cmds": "git remote prune <remote>"
},
{
        "title": "Обновление конкретного подмодуля",
        "content": "Чтобы обновить конкретный подмодуль в репозитории, нужно добавить путь к подмодулю: \n\n `git submodule update --remote --merge <path>` \n\n Предложено Вутером Пескье (Wouter Peschier).",
        "help": "update submodule обновление подмодуля",
        "cmds": "git submodule remote merge"
},
{
        "title": "Подготовка удалённых файлов",
        "content": "Чтобы подготовить к коммиту файлы и папки, которые были удалены локально, можно использовать специальную команду: \n\n `git add -u` \n\n Если требуется подготовить только используемый в данный момент путь, воспользуйтесь командой \n\n `git add -u .`",
        "help": "stage commit deleted files folders подготовка к коммиту удалённых файлов и папок",
        "cmds": "git add -u"
}]
